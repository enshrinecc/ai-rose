{"language":"Solidity","sources":{"src/EmeraldAbutment.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {\n    IERC721,\n    IERC721Enumerable\n} from \"openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport {ERC165Checker} from \"openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {Abutment, IdentityId} from \"./Abutment.sol\";\n\ncontract EmeraldAbutment is Abutment {\n    event TokenProposed(IERC721 indexed token);\n    event TokenApproved(IERC721 indexed token);\n\n    /// The length of time in seconds that a supported token will remain able to be bridged by sending it to this bridge endpoint. Tokens can still be sent to this endpoint and retrieved.\n    uint256 internal immutable tokenSupportDuration_;\n\n    mapping(IERC721 => uint256) public deactivationTimes;\n\n    constructor(\n        address owner,\n        uint256 trustedIdentityUpdateDelay,\n        address trustedIdentityRegistry,\n        IdentityId trustedIdentityId,\n        uint64 tokenSupportDuration\n    ) Abutment(owner, trustedIdentityUpdateDelay, trustedIdentityRegistry, trustedIdentityId) {\n        tokenSupportDuration_ = tokenSupportDuration;\n    }\n\n    function getTokenSupportDuration() external view returns (uint256) {\n        return tokenSupportDuration_;\n    }\n\n    function proposeToken(address tokenAddr, address remoteAddr) external onlyOwner {\n        if (!ERC165Checker.supportsInterface(tokenAddr, type(IERC721Enumerable).interfaceId)) {\n            revert UnsupportedToken();\n        }\n        IERC721Enumerable token = IERC721Enumerable(tokenAddr);\n        _addCollection(token, remoteAddr, token.totalSupply());\n        emit TokenProposed(token);\n    }\n\n    function deactivateToken(IERC721 token) external {\n        if (deactivationTimes[token] > block.timestamp) revert TooSoon();\n        _removeCollectionSupport(token);\n    }\n\n    function _onBallotApproved(IERC721 token) internal override {\n        deactivationTimes[token] = uint64(block.timestamp + tokenSupportDuration_);\n        _addCollectionSupport(token);\n        emit TokenApproved(token);\n    }\n\n    /// @dev Tokens cannot be bridged back to the Emerald abutment unless it was previously bridged from the portal by the same holder. This function reverts if an offending task result is found. The Saphire abutment must not accept such tokens, but we check again here for additional safety.\n    function _beforeTaskResultsAccepted(uint256[] calldata, bytes calldata, bytes calldata report)\n        internal\n        view\n        override\n    {\n        BridgeAction[] memory actions = abi.decode(report, (BridgeAction[]));\n        for (uint256 i; i < actions.length; ++i) {\n            BridgeAction memory action = actions[i];\n            Token storage token = tokens[action.token][action.tokenId];\n            if (token.presence == Presence.Unknown || action.recipient != token.owner) {\n                revert UnsupportedToken();\n            }\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Enumerable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165Checker.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"},"src/Abutment.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {TaskIdSelectorOps} from \"escrin/tasks/v1/acceptors/TaskAcceptor.sol\";\nimport {\n    IdentityId,\n    IIdentityRegistry,\n    PermittedSubmitterTaskAcceptor\n} from \"escrin/tasks/v1/acceptors/PermittedSubmitterTaskAcceptor.sol\";\nimport {TaskHubNotifier} from \"escrin/tasks/v1/hub/TaskHubNotifier.sol\";\nimport {Ownable, Ownable2Step} from \"openzeppelin/contracts/access/Ownable2Step.sol\";\nimport {IERC721Receiver} from \"openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {\n    IERC721,\n    IERC721Enumerable\n} from \"openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\";\nimport {ERC165Checker} from \"openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {EnumerableSet} from \"openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {IERC721AQueryable} from \"ERC721A/extensions/IERC721AQueryable.sol\";\n\nabstract contract Abutment is\n    IERC721Receiver,\n    PermittedSubmitterTaskAcceptor,\n    TaskHubNotifier,\n    Ownable2Step\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TaskIdSelectorOps for TaskIdSelector;\n\n    /// The token sent to the bridge contract is not supported or not approved.\n    error UnsupportedToken(); // 6a172882 ahcogg==\n    /// The reported token descriptor does not match the corresponding task id.\n    error MismatchedTask(); // 1e377d4c Hjd9TA==\n    /// The operation cannot proceed because the token has the wrong presence.\n    error NotPresent(); // faa85272 +qhScg==\n    /// This operation cannot be performed yet.\n    error TooSoon(); // 6fed7d85 b+19hQ==\n\n    enum Presence {\n        Unknown,\n        /// The token is known not to be on this network.\n        Absent,\n        /// The token is known to be on this network and is held by this abutment.\n        Abutment,\n        /// The token is known to be on this network and is held by an NFT wallet.\n        Wallet\n    }\n\n    struct Collection {\n        address remote;\n        mapping(uint256 /* token id */ => bool) voted;\n        uint64 approvingVotes;\n        uint64 quorum;\n    }\n\n    struct Token {\n        address owner;\n        Presence presence;\n    }\n\n    struct BridgeAction {\n        IERC721 token;\n        uint256 tokenId;\n        ActionEffect effect;\n        // @dev only set when ActionEffect is Release\n        address recipient;\n    }\n\n    enum ActionEffect {\n        Unknown,\n        Lock,\n        Release\n    }\n\n    struct TrustedIdentity {\n        IIdentityRegistry registry;\n        IdentityId id;\n    }\n\n    event TrustedIdentityIncoming(TrustedIdentity identity);\n\n    uint256 public immutable trustedIdentityUpdateDelay;\n    TrustedIdentity public incomingTrustedIdentity;\n    uint256 public incomingTrustedIdentityActiveTime;\n\n    mapping(IERC721 => Collection) internal collections;\n    mapping(IERC721 => mapping(uint256 => Token)) internal tokens;\n    EnumerableSet.AddressSet private supportedCollections;\n\n    constructor(\n        address owner,\n        uint256 trustedIdentityUpdateDelay_,\n        address trustedIdentityRegistry,\n        IdentityId trustedIdentityId\n    ) Ownable(owner) PermittedSubmitterTaskAcceptor(trustedIdentityRegistry, trustedIdentityId) {\n        trustedIdentityUpdateDelay = trustedIdentityUpdateDelay_;\n    }\n\n    /// Votes to take action on the token with the weight of the provided token IDs.\n    function vote(IERC721 token, uint256[] calldata tokenIds) external {\n        Collection storage coll = collections[token];\n        if (coll.quorum == 0) revert UnsupportedToken();\n\n        uint256 newApprovals;\n        for (uint256 i; i < tokenIds.length; ++i) {\n            uint256 id = tokenIds[i];\n            if (token.ownerOf(id) != msg.sender || coll.voted[id]) continue;\n            coll.voted[id] = true;\n            newApprovals++;\n        }\n        coll.approvingVotes += uint64(newApprovals);\n\n        if (coll.approvingVotes >= coll.quorum) {\n            _onBallotApproved(token);\n        }\n    }\n\n    function onERC721Received(address, address from, uint256 tokenId, bytes calldata)\n        external\n        override\n        notify\n        returns (bytes4)\n    {\n        if (!supportedCollections.contains(msg.sender)) revert UnsupportedToken();\n        IERC721 token = IERC721(msg.sender);\n        _beforeReceiveToken(token, tokenId);\n        tokens[token][tokenId] = Token({owner: from, presence: Presence.Abutment});\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n    function getVoteStatus(IERC721 token) public view returns (uint256 approvals, uint256 quorum) {\n        Collection storage coll = collections[token];\n        if (coll.quorum == 0) revert UnsupportedToken();\n        return (coll.approvingVotes, coll.quorum);\n    }\n\n    function getRemote(IERC721 token) external view returns (address) {\n        Collection storage coll = collections[token];\n        if (coll.remote == address(0)) revert UnsupportedToken();\n        return coll.remote;\n    }\n\n    function getSupportedCollections() external view returns (IERC721[] memory) {\n        IERC721[] memory nfts = new IERC721[](supportedCollections.length());\n        for (uint256 i; i < nfts.length; ++i) {\n            nfts[i] = IERC721(supportedCollections.at(i));\n        }\n        return nfts;\n    }\n\n    function getVotingTokens(address voter, IERC721 token)\n        external\n        view\n        returns (uint256[] memory votingTokens)\n    {\n        Collection storage coll = collections[token];\n        if (coll.quorum == 0) revert UnsupportedToken();\n        uint256[] memory heldTokens = _enumerateTokensOf(voter, token);\n        votingTokens = new uint256[](heldTokens.length);\n        uint256 numVotingTokens;\n        for (uint256 i; i < heldTokens.length; ++i) {\n            uint256 id = heldTokens[i];\n            if (token.ownerOf(id) != voter || coll.voted[id]) continue;\n            votingTokens[numVotingTokens++] = id;\n        }\n        assembly {\n            mstore(votingTokens, numVotingTokens)\n        }\n    }\n\n    function getHeldTokens(address holder, IERC721 token)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return _enumerateTokensOf(holder, token);\n    }\n\n    struct HeldToken {\n        uint256 id;\n        Presence presence;\n    }\n\n    function getTokensByHolder(address holder, IERC721 token)\n        external\n        view\n        returns (HeldToken[] memory)\n    {\n        uint256[] memory abutmentTokens = _enumerateTokensOf(address(this), token);\n        uint256[] memory holderTokens = _enumerateTokensOf(holder, token);\n        uint256 maxTokens = abutmentTokens.length + holderTokens.length;\n        HeldToken[] memory heldTokens = new HeldToken[](maxTokens);\n        uint256 writeIndex;\n        for (uint256 i; i < abutmentTokens.length; i++) {\n            uint256 id = abutmentTokens[i];\n            Token storage tok = tokens[token][id];\n            if (tok.owner != holder) continue;\n            heldTokens[writeIndex++] = HeldToken({id: id, presence: tok.presence});\n        }\n        for (uint256 i; i < holderTokens.length; i++) {\n            uint256 id = holderTokens[i];\n            heldTokens[writeIndex++] = HeldToken({id: id, presence: tokens[token][id].presence});\n        }\n        assembly {\n            mstore(heldTokens, writeIndex)\n        }\n        return heldTokens;\n    }\n\n    function getTokenStatuses(IERC721 token, uint256[] calldata ids)\n        external\n        view\n        returns (Token[] memory)\n    {\n        Token[] memory ts = new Token[](ids.length);\n        for (uint256 i; i < ids.length; ++i) {\n            ts[i] = tokens[token][ids[i]];\n        }\n        return ts;\n    }\n\n    function setTrustedIdentity(TrustedIdentity calldata identity) external onlyOwner {\n        if (\n            identity.registry == incomingTrustedIdentity.registry\n                && IdentityId.unwrap(identity.id) == IdentityId.unwrap(incomingTrustedIdentity.id)\n        ) {\n            if (incomingTrustedIdentityActiveTime > block.timestamp) revert TooSoon();\n            _setTrustedIdentity(address(identity.registry), identity.id);\n            delete incomingTrustedIdentity;\n            delete incomingTrustedIdentityActiveTime;\n            return;\n        }\n        incomingTrustedIdentity = identity;\n        incomingTrustedIdentityActiveTime = block.timestamp + trustedIdentityUpdateDelay;\n        emit TrustedIdentityIncoming(identity);\n    }\n\n    function _addCollection(IERC721 token, address remoteToken, uint256 totalSupply) internal {\n        Collection storage coll = collections[token];\n        require(coll.quorum == 0, \"already exists\");\n        require(\n            remoteToken != address(0) && totalSupply > 0 && totalSupply < type(uint64).max,\n            \"invalid request\"\n        );\n        (coll.remote, coll.quorum) = (remoteToken, uint64((totalSupply >> 1) + 1));\n    }\n\n    function _addCollectionSupport(IERC721 token) internal {\n        supportedCollections.add(address(token));\n    }\n\n    function _removeCollectionSupport(IERC721 token) internal {\n        supportedCollections.remove(address(token));\n    }\n\n    /// @dev An abstraction over IERC721Enumerable and ERC721AQueryable that gets all items owned by the abutment for a particular collection. This should work for all Oasis collections that are very small and do not need pagination. This could cost a lot of gas, so it should not be called in a tx.\n    function _enumerateTokensOf(address holder, IERC721 token)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        if (ERC165Checker.supportsInterface(address(token), type(IERC721Enumerable).interfaceId)) {\n            IERC721Enumerable enumerableToken = IERC721Enumerable(address(token));\n            uint256[] memory heldTokens = new uint256[](token.balanceOf(holder));\n            for (uint256 i; i < heldTokens.length; ++i) {\n                heldTokens[i] = enumerableToken.tokenOfOwnerByIndex(holder, i);\n            }\n            return heldTokens;\n        }\n        return IERC721AQueryable(address(token)).tokensOfOwner(holder);\n    }\n\n    function _onBallotApproved(IERC721 token) internal virtual;\n\n    function _beforeReceiveToken(IERC721 token, uint256 id) internal view virtual {}\n\n    function _afterTaskResultsAccepted(\n        uint256[] calldata taskIds,\n        bytes calldata report,\n        TaskIdSelector memory selected\n    ) internal override {\n        uint256[] memory acceptedIxs = selected.indices(taskIds);\n        BridgeAction[] memory actions = abi.decode(report, (BridgeAction[]));\n        for (uint256 i; i < acceptedIxs.length; ++i) {\n            BridgeAction memory action = actions[acceptedIxs[i]];\n            Token storage token = tokens[action.token][action.tokenId];\n\n            require(action.effect != ActionEffect.Unknown, \"invalid submission\");\n            if (action.effect == ActionEffect.Lock) {\n                if (token.presence != Presence.Abutment) continue;\n                token.presence = Presence.Absent;\n                continue;\n            }\n            // The token is being released.\n            // It may not yet exist on this side of the bridge, which would make its presence unknown.\n            if (token.presence != Presence.Unknown && token.presence != Presence.Absent) continue;\n            action.token.transferFrom(address(this), action.recipient, action.tokenId);\n            token.presence = Presence.Wallet;\n        }\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},"lib/escrin/evm/src/tasks/v1/acceptors/TaskAcceptor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {ERC165, IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {ITaskAcceptor, TaskIdSelectorOps} from \"../ITaskAcceptor.sol\";\n\nabstract contract TaskAcceptor is ITaskAcceptor, ERC165 {\n    /// The input task ids were not sorted.\n    error SubmisionTaskIdsNotSorted(); // E+1Qrg== 13ed50ae\n    /// The set of accepted task ids was not sorted.\n    error AcceptedTaskIdsNotSorted(); // WjXPLQ== 5a35cf2d\n\n    using TaskIdSelectorOps for TaskIdSelector;\n\n    function acceptTaskResults(\n        uint256[] calldata taskIds,\n        bytes calldata proof,\n        bytes calldata report\n    ) external virtual returns (TaskIdSelector memory sel) {\n        if (!_isSortedSet(taskIds)) revert SubmisionTaskIdsNotSorted();\n        _beforeTaskResultsAccepted({taskIds: taskIds, proof: proof, report: report});\n        sel = _acceptTaskResults({taskIds: taskIds, proof: proof, report: report});\n        if (!_isSortedSet(sel.taskIds)) revert AcceptedTaskIdsNotSorted();\n        _afterTaskResultsAccepted({taskIds: taskIds, report: report, selected: sel});\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(ITaskAcceptor).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /// Accepts one or more elements of a task runner's task results submission, returning the set of tasks that were accepted.\n    /// @param taskIds a sorted set of taskIds completed in this submission\n    /// @param proof some proof of having completed the identified tasks that the acceptor can verify.\n    /// @param report Some data provided by the submitter that the requester may or may not trust\n    /// @return A selection of the accepted task results, which may be empty.\n    function _acceptTaskResults(\n        uint256[] calldata taskIds,\n        bytes calldata proof,\n        bytes calldata report\n    ) internal virtual returns (TaskIdSelector memory);\n\n    /// Runs before tasks are accepted.\n    function _beforeTaskResultsAccepted(\n        uint256[] calldata taskIds,\n        bytes calldata proof,\n        bytes calldata report\n    ) internal virtual {\n        (taskIds, proof, report);\n    }\n\n    function _afterTaskResultsAccepted(\n        uint256[] calldata taskIds,\n        bytes calldata report,\n        TaskIdSelector memory selected\n    ) internal virtual {\n        (taskIds, report, selected);\n    }\n\n    function _isSortedSet(uint256[] memory input) internal pure returns (bool) {\n        for (uint256 i = 1; i < input.length; ++i) {\n            if (input[i] <= input[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"},"lib/escrin/evm/src/tasks/v1/acceptors/PermittedSubmitterTaskAcceptor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {IdentityId, IIdentityRegistry} from \"../../../identity/v1/IIdentityRegistry.sol\";\nimport {TaskAcceptor} from \"./TaskAcceptor.sol\";\n\nabstract contract PermittedSubmitterTaskAcceptor is TaskAcceptor {\n    /// The provided contract address does not support the correct interface.\n    error InterfaceUnsupported(); // bbaa55aa u6pVqg==\n\n    IIdentityRegistry private identityRegistry_;\n    IdentityId private trustedIdentity_;\n\n    constructor(address identityRegistry, IdentityId trustedIdentity) {\n        identityRegistry_ = _requireIsIdentityRegistry(identityRegistry);\n        trustedIdentity_ = trustedIdentity;\n    }\n\n    function getTrustedIdentity() external view returns (IIdentityRegistry, IdentityId) {\n        return (identityRegistry_, trustedIdentity_);\n    }\n\n    function _acceptTaskResults(uint256[] calldata, bytes calldata, bytes calldata)\n        internal\n        virtual\n        override\n        returns (TaskIdSelector memory sel)\n    {\n        sel.quantifier = _isPermittedSubmitter(msg.sender) ? Quantifier.All : Quantifier.None;\n    }\n\n    function _setTrustedIdentity(address registry, IdentityId identity) internal {\n        identityRegistry_ = _requireIsIdentityRegistry(registry);\n        trustedIdentity_ = identity;\n    }\n\n    function _isPermittedSubmitter(address submitter) internal view returns (bool) {\n        IIdentityRegistry.Permit memory permit =\n            identityRegistry_.readPermit(submitter, trustedIdentity_);\n        return permit.expiry > block.timestamp;\n    }\n\n    function _requireIsIdentityRegistry(address registry)\n        private\n        view\n        returns (IIdentityRegistry)\n    {\n        if (!ERC165Checker.supportsInterface(registry, type(IIdentityRegistry).interfaceId)) {\n            revert InterfaceUnsupported();\n        }\n        return IIdentityRegistry(registry);\n    }\n}\n"},"lib/escrin/evm/src/tasks/v1/hub/TaskHubNotifier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {ITaskHub, TaskHub} from \"./TaskHub.sol\";\n\nerror NotTaskHub(); // owTjPw== a304e33f\n\ncontract BaseTaskHubNotifier {\n    event TaskHubChanged(address to);\n\n    ITaskHub private taskHub_;\n\n    modifier notify() {\n        _;\n        taskHub_.notify();\n    }\n\n    constructor(address taskHub) {\n        _setTaskHub(taskHub);\n    }\n\n    function getTaskHub() public view virtual returns (ITaskHub) {\n        return taskHub_;\n    }\n\n    function _setTaskHub(address maybeTaskHub) internal {\n        taskHub_ = _requireIsTaskHub(maybeTaskHub);\n        emit TaskHubChanged(maybeTaskHub);\n    }\n\n    function _requireIsTaskHub(address maybeTaskHub) internal view returns (ITaskHub) {\n        if (!_isTaskHub(maybeTaskHub)) revert NotTaskHub();\n        return ITaskHub(maybeTaskHub);\n    }\n\n    function _isTaskHub(address maybeTaskHub) internal view returns (bool) {\n        return ERC165Checker.supportsInterface(maybeTaskHub, type(ITaskHub).interfaceId);\n    }\n}\n\ncontract TaskHubNotifier is BaseTaskHubNotifier {\n    constructor() BaseTaskHubNotifier(inferTaskHub()) {\n        return;\n    }\n\n    function inferTaskHub() private returns (address) {\n        uint256 ch = block.chainid;\n        // Emerald\n        if (ch == 0xa515) return 0x37Dfd1a00116d59a08B97D19F95f1c2a435fF5Df;\n        if (ch == 0xa516) return 0xd0dD1dFE79bB4Ad64d727Ee99F51cb968e949bf4;\n        // Sapphire\n        if (ch == 0x5aff) return 0x63c13Ee9BecC8f35dC034F026Ae8d18A4D1E7f0E;\n        if (ch == 0x5afe) return 0x4F8f246b1aaa99810844Be20DbdD4F5B36740Ca4;\n        // Local\n        if (ch == 1337 || ch == 31337 || ch == 0x5afd) return address(new TaskHub());\n        return address(0);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.20;\n\nimport {Ownable} from \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"lib/ERC721A/contracts/extensions/IERC721AQueryable.sol":{"content":"// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\nimport '../IERC721A.sol';\n\n/**\n * @dev Interface of ERC721AQueryable.\n */\ninterface IERC721AQueryable is IERC721A {\n    /**\n     * Invalid query range (`start` >= `stop`).\n     */\n    error InvalidQueryRange();\n\n    /**\n     * @dev Returns the `TokenOwnership` struct at `tokenId` without reverting.\n     *\n     * If the `tokenId` is out of bounds:\n     *\n     * - `addr = address(0)`\n     * - `startTimestamp = 0`\n     * - `burned = false`\n     * - `extraData = 0`\n     *\n     * If the `tokenId` is burned:\n     *\n     * - `addr = <Address of owner before token was burned>`\n     * - `startTimestamp = <Timestamp when token was burned>`\n     * - `burned = true`\n     * - `extraData = <Extra data when token was burned>`\n     *\n     * Otherwise:\n     *\n     * - `addr = <Address of owner>`\n     * - `startTimestamp = <Timestamp of start of ownership>`\n     * - `burned = false`\n     * - `extraData = <Extra data at start of ownership>`\n     */\n    function explicitOwnershipOf(uint256 tokenId) external view returns (TokenOwnership memory);\n\n    /**\n     * @dev Returns an array of `TokenOwnership` structs at `tokenIds` in order.\n     * See {ERC721AQueryable-explicitOwnershipOf}\n     */\n    function explicitOwnershipsOf(uint256[] memory tokenIds) external view returns (TokenOwnership[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`,\n     * in the range [`start`, `stop`)\n     * (i.e. `start <= tokenId < stop`).\n     *\n     * This function allows for tokens to be queried if the collection\n     * grows too big for a single call of {ERC721AQueryable-tokensOfOwner}.\n     *\n     * Requirements:\n     *\n     * - `start < stop`\n     */\n    function tokensOfOwnerIn(\n        address owner,\n        uint256 start,\n        uint256 stop\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Returns an array of token IDs owned by `owner`.\n     *\n     * This function scans the ownership mapping and is O(`totalSupply`) in complexity.\n     * It is meant to be called off-chain.\n     *\n     * See {ERC721AQueryable-tokensOfOwnerIn} for splitting the scan into\n     * multiple smaller scans if the collection is large enough to cause\n     * an out-of-gas error (10K collections should be fine).\n     */\n    function tokensOfOwner(address owner) external view returns (uint256[] memory);\n}\n"},"lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * @custom:stateless\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"lib/escrin/evm/src/tasks/v1/ITaskAcceptor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nerror UnknownQuantifier(); // yrtLPA== cabb4b3c\n\ninterface ITaskAcceptor is IERC165 {\n    struct TaskIdSelector {\n        Quantifier quantifier;\n        /// A sorted list identifying subset of submitted tasks that will interpreted per the quantifier.\n        uint256[] taskIds;\n    }\n\n    enum Quantifier {\n        Unknown,\n        All,\n        None,\n        Some,\n        Excluding\n    }\n\n    /// Accepts one or more elements of a task runner's task results submission, returning the set of tasks that were accepted.\n    /// @param taskIds a sorted set of taskIds completed in this submission\n    /// @param proof some proof of having completed the identified tasks that the acceptor can verify.\n    /// @param report some data provided by the submitter that the requester may or may not trust\n    function acceptTaskResults(\n        uint256[] calldata taskIds,\n        bytes calldata proof,\n        bytes calldata report\n    ) external returns (TaskIdSelector memory);\n}\n\n/// An extension to `ITaskAcceptor` that helps task runners know where to find details about how to complete the task.\ninterface ITaskAcceptanceCriteria is ITaskAcceptor {\n    /// @return a string that could be a URI or some abi-encoded data\n    function taskAcceptanceCriteria(uint256 taskId) external view returns (string memory);\n}\n\nlibrary TaskIdSelectorOps {\n    function countSelected(ITaskAcceptor.TaskIdSelector memory sel, uint256 totalCount)\n        internal\n        pure\n        returns (uint256 count)\n    {\n        if (sel.quantifier == ITaskAcceptor.Quantifier.All) return totalCount;\n        if (sel.quantifier == ITaskAcceptor.Quantifier.None) return 0;\n        if (sel.quantifier == ITaskAcceptor.Quantifier.Some) return sel.taskIds.length;\n        if (sel.quantifier == ITaskAcceptor.Quantifier.Excluding) {\n            return totalCount - sel.taskIds.length;\n        }\n        revert UnknownQuantifier();\n    }\n\n    /// @param set a sorted set of task ids\n    function selected(ITaskAcceptor.TaskIdSelector memory sel, uint256[] memory set)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        if (sel.quantifier == ITaskAcceptor.Quantifier.All) return set;\n        if (sel.quantifier == ITaskAcceptor.Quantifier.None) return new uint256[](0);\n        if (sel.quantifier == ITaskAcceptor.Quantifier.Some) return sel.taskIds;\n        if (sel.quantifier == ITaskAcceptor.Quantifier.Excluding) {\n            uint256[] memory out = new uint256[](countSelected(sel, set.length));\n            uint256 selPtr;\n            uint256 outPtr;\n            for (uint256 setPtr; setPtr < set.length; ++setPtr) {\n                if (set[setPtr] == sel.taskIds[selPtr]) continue;\n                out[outPtr] = set[setPtr];\n                selPtr++;\n                outPtr++;\n            }\n            return out;\n        }\n        revert UnknownQuantifier();\n    }\n\n    function indices(ITaskAcceptor.TaskIdSelector memory sel, uint256[] memory set)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        if (sel.quantifier == ITaskAcceptor.Quantifier.All) {\n            uint256[] memory ixs = new uint256[](set.length);\n            for (uint256 i; i < ixs.length; ++i) {\n                ixs[i] = i;\n            }\n            return ixs;\n        }\n        if (sel.quantifier == ITaskAcceptor.Quantifier.None) return new uint256[](0);\n        if (sel.quantifier == ITaskAcceptor.Quantifier.Some) {\n            uint256[] memory ixs = new uint256[](sel.taskIds.length);\n            uint256 selPtr;\n            for (uint256 setPtr; setPtr < set.length; ++setPtr) {\n                if (set[setPtr] != sel.taskIds[selPtr]) continue;\n                ixs[selPtr] = setPtr;\n                selPtr++;\n            }\n            return ixs;\n        }\n        if (sel.quantifier == ITaskAcceptor.Quantifier.Excluding) {\n            uint256[] memory ixs = new uint256[](countSelected(sel, set.length));\n            uint256 selPtr;\n            for (uint256 setPtr; setPtr < set.length; ++setPtr) {\n                if (set[setPtr] == sel.taskIds[selPtr]) continue;\n                ixs[selPtr] = setPtr;\n                selPtr++;\n            }\n            return ixs;\n        }\n        revert UnknownQuantifier();\n    }\n\n    function pick(\n        ITaskAcceptor.TaskIdSelector memory sel,\n        uint256[] memory set,\n        uint256[] memory target\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory ixs = indices(sel, set);\n        uint256[] memory placed = new uint256[](ixs.length);\n        for (uint256 i; i < ixs.length; ++i) {\n            placed[i] = target[ixs[i]];\n        }\n        return placed;\n    }\n\n    function all() internal pure returns (ITaskAcceptor.TaskIdSelector memory sel) {\n        sel.quantifier = ITaskAcceptor.Quantifier.All;\n    }\n\n    function none() internal pure returns (ITaskAcceptor.TaskIdSelector memory sel) {\n        sel.quantifier = ITaskAcceptor.Quantifier.None;\n    }\n}\n"},"lib/escrin/evm/src/identity/v1/IIdentityRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IPermitter} from \"./IPermitter.sol\";\n\ntype IdentityId is uint256;\n\ninterface IIdentityRegistry is IERC165 {\n    /// The action is disallowed.\n    error Unauthorized(); // 82b42900 grQpAA==\n\n    /// The provided contract address does not support the correct interface.\n    error InterfaceUnsupported(); // bbaa55aa u6pVqg==\n\n    struct Permit {\n        uint64 expiry;\n    }\n\n    event RegistrationTransferProposed(IdentityId indexed identityId, address indexed proposed);\n    event PermitterChanged(IdentityId indexed identityId);\n\n    event IdentityCreated(IdentityId id);\n    event IdentityDestroyed(IdentityId indexed id);\n    event IdentityGranted(IdentityId indexed id, address indexed to);\n    event IdentityRevoked(IdentityId indexed id, address indexed from);\n\n    function createIdentity(address permitter, bytes calldata pers)\n        external\n        returns (IdentityId id);\n\n    function destroyIdentity(IdentityId id) external;\n\n    function setPermitter(IdentityId id, address permitter) external;\n\n    function proposeRegistrationTransfer(IdentityId id, address to) external;\n\n    function acceptRegistrationTransfer(IdentityId id) external;\n\n    /// Called by the identity's permitter to grant the identity to the recipient.\n    function grantIdentity(IdentityId id, address to, uint64 expiry) external;\n\n    /// Called by the identity's permitter to revoke the identity to the recipient.\n    function revokeIdentity(IdentityId id, address from) external;\n\n    function getPermitter(IdentityId id) external view returns (IPermitter);\n\n    function readPermit(address holder, IdentityId identity)\n        external\n        view\n        returns (Permit memory);\n\n    function getRegistrant(IdentityId id)\n        external\n        view\n        returns (address current, address proposed);\n}\n"},"lib/escrin/evm/src/tasks/v1/hub/TaskHub.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {ERC165, IERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {ITaskHub} from \"./ITaskHub.sol\";\n\n/// @dev The methods in this contract are not marked with `override` are not guaranteed to be in the next version of the contract.\ncontract TaskHub is ITaskHub, ERC165 {\n    function notify() external override {\n        emit TasksAvailable(msg.sender, \"\");\n    }\n\n    function notify(bytes32 context) external override {\n        emit TasksAvailable(msg.sender, context);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC165, IERC165)\n        returns (bool)\n    {\n        return interfaceId == type(ITaskHub).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"lib/ERC721A/contracts/IERC721A.sol":{"content":"// SPDX-License-Identifier: MIT\n// ERC721A Contracts v4.2.3\n// Creator: Chiru Labs\n\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of ERC721A.\n */\ninterface IERC721A {\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error ApprovalCallerNotOwnerNorApproved();\n\n    /**\n     * The token does not exist.\n     */\n    error ApprovalQueryForNonexistentToken();\n\n    /**\n     * Cannot query the balance for the zero address.\n     */\n    error BalanceQueryForZeroAddress();\n\n    /**\n     * Cannot mint to the zero address.\n     */\n    error MintToZeroAddress();\n\n    /**\n     * The quantity of tokens minted must be more than zero.\n     */\n    error MintZeroQuantity();\n\n    /**\n     * The token does not exist.\n     */\n    error OwnerQueryForNonexistentToken();\n\n    /**\n     * The caller must own the token or be an approved operator.\n     */\n    error TransferCallerNotOwnerNorApproved();\n\n    /**\n     * The token must be owned by `from`.\n     */\n    error TransferFromIncorrectOwner();\n\n    /**\n     * Cannot safely transfer to a contract that does not implement the\n     * ERC721Receiver interface.\n     */\n    error TransferToNonERC721ReceiverImplementer();\n\n    /**\n     * Cannot transfer to the zero address.\n     */\n    error TransferToZeroAddress();\n\n    /**\n     * The token does not exist.\n     */\n    error URIQueryForNonexistentToken();\n\n    /**\n     * The `quantity` minted with ERC2309 exceeds the safety limit.\n     */\n    error MintERC2309QuantityExceedsLimit();\n\n    /**\n     * The `extraData` cannot be set on an unintialized ownership slot.\n     */\n    error OwnershipNotInitializedForExtraData();\n\n    // =============================================================\n    //                            STRUCTS\n    // =============================================================\n\n    struct TokenOwnership {\n        // The address of the owner.\n        address addr;\n        // Stores the start time of ownership with minimal overhead for tokenomics.\n        uint64 startTimestamp;\n        // Whether the token has been burned.\n        bool burned;\n        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.\n        uint24 extraData;\n    }\n\n    // =============================================================\n    //                         TOKEN COUNTERS\n    // =============================================================\n\n    /**\n     * @dev Returns the total number of tokens in existence.\n     * Burned tokens will reduce the count.\n     * To get the total number of tokens minted, please see {_totalMinted}.\n     */\n    function totalSupply() external view returns (uint256);\n\n    // =============================================================\n    //                            IERC165\n    // =============================================================\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    // =============================================================\n    //                            IERC721\n    // =============================================================\n\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables\n     * (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in `owner`'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`,\n     * checking first that contract recipients are aware of the ERC721 protocol\n     * to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move\n     * this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement\n     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable;\n\n    /**\n     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}\n     * whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token\n     * by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the\n     * zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external payable;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom}\n     * for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    // =============================================================\n    //                        IERC721Metadata\n    // =============================================================\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    // =============================================================\n    //                           IERC2309\n    // =============================================================\n\n    /**\n     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`\n     * (inclusive) is transferred from `from` to `to`, as defined in the\n     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.\n     *\n     * See {_mintERC2309} for more details.\n     */\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);\n}\n"},"lib/escrin/evm/src/identity/v1/IPermitter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\nimport {IdentityId} from \"./IIdentityRegistry.sol\";\n\ninterface IPermitter is IERC165 {\n    /// Requests that the permitter trigger the upstream identity registry to grant an identity.\n    /// @param identity The identity that the requester wishes to acquire.\n    /// @param requester The account to which the identity permit will be issued.\n    /// @param duration The requested lifetime of the permit, which may be different from lifetime actually granted.\n    /// @param context Non-authentication data provided to the permitter to make its decision.\n    /// @param authorization Authentication data provided to the permitter to make its decision.\n    /// @return expiry The timestamp at which the permit expires, which may be different from the request timestamp plus the requested duration.\n    function acquireIdentity(\n        IdentityId identity,\n        address requester,\n        uint64 duration,\n        bytes calldata context,\n        bytes calldata authorization\n    ) external returns (uint64 expiry);\n\n    /// Requests that the permitter trigger the upstream identity registry to revoke an identity.\n    /// @param identity The identity that the requester wishes to acquire.\n    /// @param possessor The account that will no longer have the permit.\n    /// @param context Non-authentication data provided to the permitter to make its decision.\n    /// @param authorization Authentication data provided to the permitter to make its decision.\n    function releaseIdentity(\n        IdentityId identity,\n        address possessor,\n        bytes calldata context,\n        bytes calldata authorization\n    ) external;\n}\n"},"lib/escrin/evm/src/tasks/v1/hub/ITaskHub.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface ITaskHub is IERC165 {\n    event TasksAvailable(address indexed generator, bytes32 indexed context);\n\n    /// Alerts any listening task runners that there are new tasks available.\n    function notify() external;\n\n    /// Alerts any listening task runners that there are new tasks available.\n    /// @param context Some indexed data to be emitted with the event for listeners to filter on.\n    function notify(bytes32 context) external;\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n *\n * @custom:stateless\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"}},"settings":{"remappings":["@oasisprotocol/sapphire-contracts/contracts/=lib/sapphire-paratime/contracts/contracts/","@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","escrin/=lib/escrin/evm/src/","ERC721A/=lib/ERC721A/contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","sapphire-paratime/=lib/sapphire-paratime/"],"optimizer":{"enabled":false,"runs":200},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","libraries":{}}}
